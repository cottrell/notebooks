# coding: utf-8

"""
    Finnhub API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def aggregate_indicator(self, symbol, resolution, **kwargs):  # noqa: E501
        """Aggregate Indicators  # noqa: E501

        Get aggregate signal of multiple technical indicators such as MACD, RSI, Moving Average v.v.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.aggregate_indicator(symbol, resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: symbol (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :return: AggregateIndicators
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.aggregate_indicator_with_http_info(symbol, resolution, **kwargs)  # noqa: E501
        else:
            (data) = self.aggregate_indicator_with_http_info(symbol, resolution, **kwargs)  # noqa: E501
            return data

    def aggregate_indicator_with_http_info(self, symbol, resolution, **kwargs):  # noqa: E501
        """Aggregate Indicators  # noqa: E501

        Get aggregate signal of multiple technical indicators such as MACD, RSI, Moving Average v.v.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.aggregate_indicator_with_http_info(symbol, resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: symbol (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :return: AggregateIndicators
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'resolution']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aggregate_indicator" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `aggregate_indicator`")  # noqa: E501
        # verify the required parameter 'resolution' is set
        if self.api_client.client_side_validation and ('resolution' not in params or
                                                       params['resolution'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `resolution` when calling `aggregate_indicator`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'resolution' in params:
            query_params.append(('resolution', params['resolution']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/scan/technical-indicator', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AggregateIndicators',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_basic_financials(self, symbol, metric, **kwargs):  # noqa: E501
        """Basic Financials  # noqa: E501

        Get company basic financials such as margin, P/E ratio, 52-week high/low etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_basic_financials(symbol, metric, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param str metric: Metric type. Can be 1 of the following values <code>all</code> (required)
        :return: BasicFinancials
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_basic_financials_with_http_info(symbol, metric, **kwargs)  # noqa: E501
        else:
            (data) = self.company_basic_financials_with_http_info(symbol, metric, **kwargs)  # noqa: E501
            return data

    def company_basic_financials_with_http_info(self, symbol, metric, **kwargs):  # noqa: E501
        """Basic Financials  # noqa: E501

        Get company basic financials such as margin, P/E ratio, 52-week high/low etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_basic_financials_with_http_info(symbol, metric, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param str metric: Metric type. Can be 1 of the following values <code>all</code> (required)
        :return: BasicFinancials
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'metric']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_basic_financials" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `company_basic_financials`")  # noqa: E501
        # verify the required parameter 'metric' is set
        if self.api_client.client_side_validation and ('metric' not in params or
                                                       params['metric'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `metric` when calling `company_basic_financials`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'metric' in params:
            query_params.append(('metric', params['metric']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/metric', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BasicFinancials',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_earnings(self, symbol, **kwargs):  # noqa: E501
        """Earnings Surprises  # noqa: E501

        Get company historical quarterly earnings surprise going back to 2000.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_earnings(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param int limit: Limit number of period returned. Leave blank to get the full history.
        :return: list[EarningResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_earnings_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.company_earnings_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def company_earnings_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Earnings Surprises  # noqa: E501

        Get company historical quarterly earnings surprise going back to 2000.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_earnings_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param int limit: Limit number of period returned. Leave blank to get the full history.
        :return: list[EarningResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_earnings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `company_earnings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/earnings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EarningResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_earnings_quality_score(self, symbol, freq, **kwargs):  # noqa: E501
        """Company Earnings Quality Score  # noqa: E501

        <p>This endpoint provides Earnings Quality Score for global companies.</p><p> Earnings quality refers to the extent to which current earnings predict future earnings. \"High-quality\" earnings are expected to persist, while \"low-quality\" earnings do not. A higher score means a higher earnings quality</p><p>Finnhub uses a proprietary model which takes into consideration 4 criteria:</p> <ul style=\"list-style-type: unset; margin-left: 30px;\"><li>Profitability</li><li>Growth</li><li>Cash Generation & Capital Allocation</li><li>Leverage</li></ul><br/><p>We then compare the metrics of each company in each category against its peers in the same industry to gauge how quality its earnings is.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_earnings_quality_score(symbol, freq, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param str freq: Frequency. Currently only support <code>quarterly</code> (required)
        :return: CompanyEarningsQualityScore
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_earnings_quality_score_with_http_info(symbol, freq, **kwargs)  # noqa: E501
        else:
            (data) = self.company_earnings_quality_score_with_http_info(symbol, freq, **kwargs)  # noqa: E501
            return data

    def company_earnings_quality_score_with_http_info(self, symbol, freq, **kwargs):  # noqa: E501
        """Company Earnings Quality Score  # noqa: E501

        <p>This endpoint provides Earnings Quality Score for global companies.</p><p> Earnings quality refers to the extent to which current earnings predict future earnings. \"High-quality\" earnings are expected to persist, while \"low-quality\" earnings do not. A higher score means a higher earnings quality</p><p>Finnhub uses a proprietary model which takes into consideration 4 criteria:</p> <ul style=\"list-style-type: unset; margin-left: 30px;\"><li>Profitability</li><li>Growth</li><li>Cash Generation & Capital Allocation</li><li>Leverage</li></ul><br/><p>We then compare the metrics of each company in each category against its peers in the same industry to gauge how quality its earnings is.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_earnings_quality_score_with_http_info(symbol, freq, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param str freq: Frequency. Currently only support <code>quarterly</code> (required)
        :return: CompanyEarningsQualityScore
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'freq']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_earnings_quality_score" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `company_earnings_quality_score`")  # noqa: E501
        # verify the required parameter 'freq' is set
        if self.api_client.client_side_validation and ('freq' not in params or
                                                       params['freq'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `freq` when calling `company_earnings_quality_score`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'freq' in params:
            query_params.append(('freq', params['freq']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/earnings-quality-score', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyEarningsQualityScore',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_eps_estimates(self, symbol, **kwargs):  # noqa: E501
        """Earnings Estimates  # noqa: E501

        Get company's EPS estimates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_eps_estimates(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param str freq: Can take 1 of the following values: <code>annual, quarterly</code>. Default to <code>quarterly</code>
        :return: EarningsEstimates
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_eps_estimates_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.company_eps_estimates_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def company_eps_estimates_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Earnings Estimates  # noqa: E501

        Get company's EPS estimates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_eps_estimates_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param str freq: Can take 1 of the following values: <code>annual, quarterly</code>. Default to <code>quarterly</code>
        :return: EarningsEstimates
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'freq']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_eps_estimates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `company_eps_estimates`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'freq' in params:
            query_params.append(('freq', params['freq']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/eps-estimate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EarningsEstimates',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_esg_score(self, symbol, **kwargs):  # noqa: E501
        """Company ESG Scores  # noqa: E501

        <p>This endpoint provides ESG scores and important indicators for 1000+ global companies. The data is collected through company's public ESG disclosure and public sources.</p><p>Our ESG scoring models takes into account more than 150 different inputs to calculate the level of ESG risks and how well a company is managing them. A higher score means lower ESG risk or better ESG management. ESG scores are in the the range of 0-100. Some key indicators might contain letter-grade score from C- to A+ with C- is the lowest score and A+ is the highest score.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_esg_score(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: CompanyESG
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_esg_score_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.company_esg_score_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def company_esg_score_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Company ESG Scores  # noqa: E501

        <p>This endpoint provides ESG scores and important indicators for 1000+ global companies. The data is collected through company's public ESG disclosure and public sources.</p><p>Our ESG scoring models takes into account more than 150 different inputs to calculate the level of ESG risks and how well a company is managing them. A higher score means lower ESG risk or better ESG management. ESG scores are in the the range of 0-100. Some key indicators might contain letter-grade score from C- to A+ with C- is the lowest score and A+ is the highest score.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_esg_score_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: CompanyESG
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_esg_score" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `company_esg_score`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/esg', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyESG',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_executive(self, symbol, **kwargs):  # noqa: E501
        """Company Executive  # noqa: E501

        Get a list of company's executives and members of the Board.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_executive(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :return: CompanyExecutive
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_executive_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.company_executive_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def company_executive_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Company Executive  # noqa: E501

        Get a list of company's executives and members of the Board.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_executive_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :return: CompanyExecutive
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_executive" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `company_executive`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/executive', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyExecutive',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_news(self, symbol, _from, to, **kwargs):  # noqa: E501
        """Company News  # noqa: E501

        List latest company news by symbol. This endpoint is only available for North American companies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_news(symbol, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol. (required)
        :param date _from: From date <code>YYYY-MM-DD</code>. (required)
        :param date to: To date <code>YYYY-MM-DD</code>. (required)
        :return: list[CompanyNews]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_news_with_http_info(symbol, _from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.company_news_with_http_info(symbol, _from, to, **kwargs)  # noqa: E501
            return data

    def company_news_with_http_info(self, symbol, _from, to, **kwargs):  # noqa: E501
        """Company News  # noqa: E501

        List latest company news by symbol. This endpoint is only available for North American companies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_news_with_http_info(symbol, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol. (required)
        :param date _from: From date <code>YYYY-MM-DD</code>. (required)
        :param date to: To date <code>YYYY-MM-DD</code>. (required)
        :return: list[CompanyNews]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_news" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `company_news`")  # noqa: E501
        # verify the required parameter '_from' is set
        if self.api_client.client_side_validation and ('_from' not in params or
                                                       params['_from'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_from` when calling `company_news`")  # noqa: E501
        # verify the required parameter 'to' is set
        if self.api_client.client_side_validation and ('to' not in params or
                                                       params['to'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `to` when calling `company_news`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/company-news', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CompanyNews]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_peers(self, symbol, **kwargs):  # noqa: E501
        """Peers  # noqa: E501

        Get company peers. Return a list of peers in the same country and sub-industry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_peers(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_peers_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.company_peers_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def company_peers_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Peers  # noqa: E501

        Get company peers. Return a list of peers in the same country and sub-industry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_peers_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_peers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `company_peers`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/peers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_profile(self, **kwargs):  # noqa: E501
        """Company Profile  # noqa: E501

        Get general information of a company. You can query by symbol, ISIN or CUSIP  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_profile(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL e.g.
        :param str isin: ISIN
        :param str cusip: CUSIP
        :return: CompanyProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_profile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.company_profile_with_http_info(**kwargs)  # noqa: E501
            return data

    def company_profile_with_http_info(self, **kwargs):  # noqa: E501
        """Company Profile  # noqa: E501

        Get general information of a company. You can query by symbol, ISIN or CUSIP  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_profile_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL e.g.
        :param str isin: ISIN
        :param str cusip: CUSIP
        :return: CompanyProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'isin', 'cusip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_profile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'isin' in params:
            query_params.append(('isin', params['isin']))  # noqa: E501
        if 'cusip' in params:
            query_params.append(('cusip', params['cusip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_profile2(self, **kwargs):  # noqa: E501
        """Company Profile 2  # noqa: E501

        Get general information of a company. You can query by symbol, ISIN or CUSIP. This is the free version of <a href=\"#company-profile\">Company Profile</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_profile2(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL e.g.
        :param str isin: ISIN
        :param str cusip: CUSIP
        :return: CompanyProfile2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_profile2_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.company_profile2_with_http_info(**kwargs)  # noqa: E501
            return data

    def company_profile2_with_http_info(self, **kwargs):  # noqa: E501
        """Company Profile 2  # noqa: E501

        Get general information of a company. You can query by symbol, ISIN or CUSIP. This is the free version of <a href=\"#company-profile\">Company Profile</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_profile2_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL e.g.
        :param str isin: ISIN
        :param str cusip: CUSIP
        :return: CompanyProfile2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'isin', 'cusip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_profile2" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'isin' in params:
            query_params.append(('isin', params['isin']))  # noqa: E501
        if 'cusip' in params:
            query_params.append(('cusip', params['cusip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/profile2', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyProfile2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def company_revenue_estimates(self, symbol, **kwargs):  # noqa: E501
        """Revenue Estimates  # noqa: E501

        Get company's revenue estimates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_revenue_estimates(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param str freq: Can take 1 of the following values: <code>annual, quarterly</code>. Default to <code>quarterly</code>
        :return: RevenueEstimates
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.company_revenue_estimates_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.company_revenue_estimates_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def company_revenue_estimates_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Revenue Estimates  # noqa: E501

        Get company's revenue estimates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.company_revenue_estimates_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param str freq: Can take 1 of the following values: <code>annual, quarterly</code>. Default to <code>quarterly</code>
        :return: RevenueEstimates
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'freq']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method company_revenue_estimates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `company_revenue_estimates`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'freq' in params:
            query_params.append(('freq', params['freq']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/revenue-estimate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevenueEstimates',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def country(self, **kwargs):  # noqa: E501
        """Country Metadata  # noqa: E501

        List all countries and metadata.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.country(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CountryMetadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.country_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.country_with_http_info(**kwargs)  # noqa: E501
            return data

    def country_with_http_info(self, **kwargs):  # noqa: E501
        """Country Metadata  # noqa: E501

        List all countries and metadata.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.country_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CountryMetadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method country" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/country', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CountryMetadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def covid19(self, **kwargs):  # noqa: E501
        """COVID-19  # noqa: E501

        Get real-time updates on the number of COVID-19 (Corona virus) cases in the US with a state-by-state breakdown. Data is sourced from CDC and reputable sources. You can also access this API <a href=\"https://rapidapi.com/Finnhub/api/finnhub-real-time-covid-19\" target=\"_blank\" rel=\"nofollow\">here</a>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.covid19(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CovidInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.covid19_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.covid19_with_http_info(**kwargs)  # noqa: E501
            return data

    def covid19_with_http_info(self, **kwargs):  # noqa: E501
        """COVID-19  # noqa: E501

        Get real-time updates on the number of COVID-19 (Corona virus) cases in the US with a state-by-state breakdown. Data is sourced from CDC and reputable sources. You can also access this API <a href=\"https://rapidapi.com/Finnhub/api/finnhub-real-time-covid-19\" target=\"_blank\" rel=\"nofollow\">here</a>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.covid19_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CovidInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method covid19" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/covid19/us', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CovidInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def crypto_candles(self, symbol, resolution, _from, to, **kwargs):  # noqa: E501
        """Crypto Candles  # noqa: E501

        Get candlestick data for crypto symbols.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.crypto_candles(symbol, resolution, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Use symbol returned in <code>/crypto/symbol</code> endpoint for this field. (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :param int _from: UNIX timestamp. Interval initial value. (required)
        :param int to: UNIX timestamp. Interval end value. (required)
        :return: CryptoCandles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.crypto_candles_with_http_info(symbol, resolution, _from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.crypto_candles_with_http_info(symbol, resolution, _from, to, **kwargs)  # noqa: E501
            return data

    def crypto_candles_with_http_info(self, symbol, resolution, _from, to, **kwargs):  # noqa: E501
        """Crypto Candles  # noqa: E501

        Get candlestick data for crypto symbols.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.crypto_candles_with_http_info(symbol, resolution, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Use symbol returned in <code>/crypto/symbol</code> endpoint for this field. (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :param int _from: UNIX timestamp. Interval initial value. (required)
        :param int to: UNIX timestamp. Interval end value. (required)
        :return: CryptoCandles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'resolution', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method crypto_candles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `crypto_candles`")  # noqa: E501
        # verify the required parameter 'resolution' is set
        if self.api_client.client_side_validation and ('resolution' not in params or
                                                       params['resolution'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `resolution` when calling `crypto_candles`")  # noqa: E501
        # verify the required parameter '_from' is set
        if self.api_client.client_side_validation and ('_from' not in params or
                                                       params['_from'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_from` when calling `crypto_candles`")  # noqa: E501
        # verify the required parameter 'to' is set
        if self.api_client.client_side_validation and ('to' not in params or
                                                       params['to'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `to` when calling `crypto_candles`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'resolution' in params:
            query_params.append(('resolution', params['resolution']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/candle', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CryptoCandles',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def crypto_exchanges(self, **kwargs):  # noqa: E501
        """Crypto Exchanges  # noqa: E501

        List supported crypto exchanges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.crypto_exchanges(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.crypto_exchanges_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.crypto_exchanges_with_http_info(**kwargs)  # noqa: E501
            return data

    def crypto_exchanges_with_http_info(self, **kwargs):  # noqa: E501
        """Crypto Exchanges  # noqa: E501

        List supported crypto exchanges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.crypto_exchanges_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method crypto_exchanges" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/exchange', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def crypto_symbols(self, exchange, **kwargs):  # noqa: E501
        """Crypto Symbol  # noqa: E501

        List supported crypto symbols by exchange  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.crypto_symbols(exchange, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str exchange: Exchange you want to get the list of symbols from. (required)
        :return: list[CryptoSymbol]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.crypto_symbols_with_http_info(exchange, **kwargs)  # noqa: E501
        else:
            (data) = self.crypto_symbols_with_http_info(exchange, **kwargs)  # noqa: E501
            return data

    def crypto_symbols_with_http_info(self, exchange, **kwargs):  # noqa: E501
        """Crypto Symbol  # noqa: E501

        List supported crypto symbols by exchange  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.crypto_symbols_with_http_info(exchange, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str exchange: Exchange you want to get the list of symbols from. (required)
        :return: list[CryptoSymbol]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exchange']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method crypto_symbols" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'exchange' is set
        if self.api_client.client_side_validation and ('exchange' not in params or
                                                       params['exchange'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `exchange` when calling `crypto_symbols`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/crypto/symbol', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CryptoSymbol]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def earnings_calendar(self, **kwargs):  # noqa: E501
        """Earnings Calendar  # noqa: E501

        Get historical and coming earnings release. EPS and Revenue in this endpoint are non-GAAP, which means they are adjusted to exclude some one-time or unusual items. This is the same data investors usually react to and talked about on the media. Estimates are sourced from both sell-side and buy-side analysts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.earnings_calendar(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date _from: From date: 2020-03-15.
        :param date to: To date: 2020-03-16.
        :param str symbol: Filter by symbol: AAPL.
        :param bool international: Set to <code>true</code> to include international markets. Default value is <code>false</code>
        :return: EarningsCalendar
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.earnings_calendar_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.earnings_calendar_with_http_info(**kwargs)  # noqa: E501
            return data

    def earnings_calendar_with_http_info(self, **kwargs):  # noqa: E501
        """Earnings Calendar  # noqa: E501

        Get historical and coming earnings release. EPS and Revenue in this endpoint are non-GAAP, which means they are adjusted to exclude some one-time or unusual items. This is the same data investors usually react to and talked about on the media. Estimates are sourced from both sell-side and buy-side analysts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.earnings_calendar_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date _from: From date: 2020-03-15.
        :param date to: To date: 2020-03-16.
        :param str symbol: Filter by symbol: AAPL.
        :param bool international: Set to <code>true</code> to include international markets. Default value is <code>false</code>
        :return: EarningsCalendar
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['_from', 'to', 'symbol', 'international']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method earnings_calendar" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'international' in params:
            query_params.append(('international', params['international']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/calendar/earnings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EarningsCalendar',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def economic_calendar(self, **kwargs):  # noqa: E501
        """Economic Calendar  # noqa: E501

        <p>Get recent and upcoming economic releases.</p><p>Historical events and surprises are available for Enterprise clients.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.economic_calendar(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EconomicCalendar
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.economic_calendar_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.economic_calendar_with_http_info(**kwargs)  # noqa: E501
            return data

    def economic_calendar_with_http_info(self, **kwargs):  # noqa: E501
        """Economic Calendar  # noqa: E501

        <p>Get recent and upcoming economic releases.</p><p>Historical events and surprises are available for Enterprise clients.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.economic_calendar_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EconomicCalendar
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method economic_calendar" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/calendar/economic', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EconomicCalendar',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def economic_code(self, **kwargs):  # noqa: E501
        """Economic Code  # noqa: E501

        List codes of supported economic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.economic_code(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[EconomicCode]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.economic_code_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.economic_code_with_http_info(**kwargs)  # noqa: E501
            return data

    def economic_code_with_http_info(self, **kwargs):  # noqa: E501
        """Economic Code  # noqa: E501

        List codes of supported economic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.economic_code_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[EconomicCode]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method economic_code" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/economic/code', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EconomicCode]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def economic_data(self, code, **kwargs):  # noqa: E501
        """Economic Data  # noqa: E501

        Get economic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.economic_data(code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str code: Economic code. (required)
        :return: EconomicData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.economic_data_with_http_info(code, **kwargs)  # noqa: E501
        else:
            (data) = self.economic_data_with_http_info(code, **kwargs)  # noqa: E501
            return data

    def economic_data_with_http_info(self, code, **kwargs):  # noqa: E501
        """Economic Data  # noqa: E501

        Get economic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.economic_data_with_http_info(code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str code: Economic code. (required)
        :return: EconomicData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['code']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method economic_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'code' is set
        if self.api_client.client_side_validation and ('code' not in params or
                                                       params['code'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `code` when calling `economic_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'code' in params:
            query_params.append(('code', params['code']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/economic', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EconomicData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def etfs_country_exposure(self, symbol, **kwargs):  # noqa: E501
        """ETFs Country Exposure  # noqa: E501

        Get ETF country exposure data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.etfs_country_exposure(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: ETF symbol. (required)
        :return: ETFsCountryExposure
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.etfs_country_exposure_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.etfs_country_exposure_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def etfs_country_exposure_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """ETFs Country Exposure  # noqa: E501

        Get ETF country exposure data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.etfs_country_exposure_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: ETF symbol. (required)
        :return: ETFsCountryExposure
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method etfs_country_exposure" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `etfs_country_exposure`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/etf/country', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ETFsCountryExposure',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def etfs_holdings(self, **kwargs):  # noqa: E501
        """ETFs Holdings  # noqa: E501

        Get full ETF holdings/constituents. This endpoint has global coverage. Widget only shows top 10 holdings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.etfs_holdings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: ETF symbol.
        :param str isin: ETF isin.
        :param int skip: Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip=0 or not set.
        :return: ETFsHoldings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.etfs_holdings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.etfs_holdings_with_http_info(**kwargs)  # noqa: E501
            return data

    def etfs_holdings_with_http_info(self, **kwargs):  # noqa: E501
        """ETFs Holdings  # noqa: E501

        Get full ETF holdings/constituents. This endpoint has global coverage. Widget only shows top 10 holdings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.etfs_holdings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: ETF symbol.
        :param str isin: ETF isin.
        :param int skip: Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip=0 or not set.
        :return: ETFsHoldings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'isin', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method etfs_holdings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'isin' in params:
            query_params.append(('isin', params['isin']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/etf/holdings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ETFsHoldings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def etfs_profile(self, **kwargs):  # noqa: E501
        """ETFs Profile  # noqa: E501

        Get ETF profile information. This endpoint has global coverage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.etfs_profile(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: ETF symbol.
        :param str isin: ETF isin.
        :return: ETFsProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.etfs_profile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.etfs_profile_with_http_info(**kwargs)  # noqa: E501
            return data

    def etfs_profile_with_http_info(self, **kwargs):  # noqa: E501
        """ETFs Profile  # noqa: E501

        Get ETF profile information. This endpoint has global coverage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.etfs_profile_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: ETF symbol.
        :param str isin: ETF isin.
        :return: ETFsProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'isin']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method etfs_profile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'isin' in params:
            query_params.append(('isin', params['isin']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/etf/profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ETFsProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def etfs_sector_exposure(self, symbol, **kwargs):  # noqa: E501
        """ETFs Sector Exposure  # noqa: E501

        Get ETF sector exposure data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.etfs_sector_exposure(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: ETF symbol. (required)
        :return: ETFsSectorExposure
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.etfs_sector_exposure_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.etfs_sector_exposure_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def etfs_sector_exposure_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """ETFs Sector Exposure  # noqa: E501

        Get ETF sector exposure data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.etfs_sector_exposure_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: ETF symbol. (required)
        :return: ETFsSectorExposure
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method etfs_sector_exposure" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `etfs_sector_exposure`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/etf/sector', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ETFsSectorExposure',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fda_committee_meeting_calendar(self, **kwargs):  # noqa: E501
        """FDA Committee Meeting Calendar  # noqa: E501

        FDA's advisory committees are established to provide functions which support the agency's mission of protecting and promoting the public health, while meeting the requirements set forth in the Federal Advisory Committee Act. Committees are either mandated by statute or established at the discretion of the Department of Health and Human Services. Each committee is subject to renewal at two-year intervals unless the committee charter states otherwise.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fda_committee_meeting_calendar(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[FDAComitteeMeeting]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fda_committee_meeting_calendar_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.fda_committee_meeting_calendar_with_http_info(**kwargs)  # noqa: E501
            return data

    def fda_committee_meeting_calendar_with_http_info(self, **kwargs):  # noqa: E501
        """FDA Committee Meeting Calendar  # noqa: E501

        FDA's advisory committees are established to provide functions which support the agency's mission of protecting and promoting the public health, while meeting the requirements set forth in the Federal Advisory Committee Act. Committees are either mandated by statute or established at the discretion of the Department of Health and Human Services. Each committee is subject to renewal at two-year intervals unless the committee charter states otherwise.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fda_committee_meeting_calendar_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[FDAComitteeMeeting]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fda_committee_meeting_calendar" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/fda-advisory-committee-calendar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FDAComitteeMeeting]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filings(self, **kwargs):  # noqa: E501
        """SEC Filings  # noqa: E501

        List company's filing. Limit to 250 documents at a time. This data is available for bulk download on <a href=\"https://www.kaggle.com/finnhub/sec-filings\" target=\"_blank\">Kaggle SEC Filings database</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. Leave <code>symbol</code>,<code>cik</code> and <code>accessNumber</code> empty to list latest filings.
        :param str cik: CIK.
        :param str access_number: Access number of a specific report you want to retrieve data from.
        :param str form: Filter by form. You can use this value <code>NT 10-K</code> to find non-timely filings for a company.
        :param date _from: From date: 2020-03-15.
        :param date to: To date: 2020-03-16.
        :return: list[Filing]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.filings_with_http_info(**kwargs)  # noqa: E501
            return data

    def filings_with_http_info(self, **kwargs):  # noqa: E501
        """SEC Filings  # noqa: E501

        List company's filing. Limit to 250 documents at a time. This data is available for bulk download on <a href=\"https://www.kaggle.com/finnhub/sec-filings\" target=\"_blank\">Kaggle SEC Filings database</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. Leave <code>symbol</code>,<code>cik</code> and <code>accessNumber</code> empty to list latest filings.
        :param str cik: CIK.
        :param str access_number: Access number of a specific report you want to retrieve data from.
        :param str form: Filter by form. You can use this value <code>NT 10-K</code> to find non-timely filings for a company.
        :param date _from: From date: 2020-03-15.
        :param date to: To date: 2020-03-16.
        :return: list[Filing]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'cik', 'access_number', 'form', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'cik' in params:
            query_params.append(('cik', params['cik']))  # noqa: E501
        if 'access_number' in params:
            query_params.append(('accessNumber', params['access_number']))  # noqa: E501
        if 'form' in params:
            query_params.append(('form', params['form']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/filings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Filing]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filings_sentiment(self, access_number, **kwargs):  # noqa: E501
        """SEC Sentiment Analysis  # noqa: E501

        Get sentiment analysis of 10-K and 10-Q filings from SEC. An abnormal increase in the number of positive/negative words in filings can signal a significant change in the company's stock price in the upcoming 4 quarters. We make use of <a href= \"https://sraf.nd.edu/textual-analysis/resources/\" target=\"_blank\">Loughran and McDonald Sentiment Word Lists</a> to calculate the sentiment for each filing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filings_sentiment(access_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str access_number: Access number of a specific report you want to retrieve data from. (required)
        :return: SECSentimentAnalysis
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filings_sentiment_with_http_info(access_number, **kwargs)  # noqa: E501
        else:
            (data) = self.filings_sentiment_with_http_info(access_number, **kwargs)  # noqa: E501
            return data

    def filings_sentiment_with_http_info(self, access_number, **kwargs):  # noqa: E501
        """SEC Sentiment Analysis  # noqa: E501

        Get sentiment analysis of 10-K and 10-Q filings from SEC. An abnormal increase in the number of positive/negative words in filings can signal a significant change in the company's stock price in the upcoming 4 quarters. We make use of <a href= \"https://sraf.nd.edu/textual-analysis/resources/\" target=\"_blank\">Loughran and McDonald Sentiment Word Lists</a> to calculate the sentiment for each filing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filings_sentiment_with_http_info(access_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str access_number: Access number of a specific report you want to retrieve data from. (required)
        :return: SECSentimentAnalysis
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filings_sentiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'access_number' is set
        if self.api_client.client_side_validation and ('access_number' not in params or
                                                       params['access_number'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `access_number` when calling `filings_sentiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'access_number' in params:
            query_params.append(('accessNumber', params['access_number']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/filings-sentiment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SECSentimentAnalysis',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def financials(self, symbol, statement, freq, **kwargs):  # noqa: E501
        """Financial Statements  # noqa: E501

        <p>Get standardized balance sheet, income statement and cash flow for global companies going back 30+ years. Data is sourced from original filings most of which made available through <a href=\"#filings\">SEC Filings</a> and <a href=\"#international-filings\">International Filings</a> endpoints.</p><p><i>Wondering why our standardized data is different from Bloomberg, Reuters, Factset, S&P or Yahoo Finance ? Check out our <a href=\"/faq\">FAQ page</a> to learn more</i></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.financials(symbol, statement, freq, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param str statement: Statement can take 1 of these values <code>bs, ic, cf</code> for Balance Sheet, Income Statement, Cash Flow respectively. (required)
        :param str freq: Frequency can take 1 of these values <code>annual, quarterly, ttm, ytd</code>.  TTM (Trailing Twelve Months) option is available for Income Statement and Cash Flow. YTD (Year To Date) option is only available for Cash Flow. (required)
        :return: FinancialStatements
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.financials_with_http_info(symbol, statement, freq, **kwargs)  # noqa: E501
        else:
            (data) = self.financials_with_http_info(symbol, statement, freq, **kwargs)  # noqa: E501
            return data

    def financials_with_http_info(self, symbol, statement, freq, **kwargs):  # noqa: E501
        """Financial Statements  # noqa: E501

        <p>Get standardized balance sheet, income statement and cash flow for global companies going back 30+ years. Data is sourced from original filings most of which made available through <a href=\"#filings\">SEC Filings</a> and <a href=\"#international-filings\">International Filings</a> endpoints.</p><p><i>Wondering why our standardized data is different from Bloomberg, Reuters, Factset, S&P or Yahoo Finance ? Check out our <a href=\"/faq\">FAQ page</a> to learn more</i></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.financials_with_http_info(symbol, statement, freq, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param str statement: Statement can take 1 of these values <code>bs, ic, cf</code> for Balance Sheet, Income Statement, Cash Flow respectively. (required)
        :param str freq: Frequency can take 1 of these values <code>annual, quarterly, ttm, ytd</code>.  TTM (Trailing Twelve Months) option is available for Income Statement and Cash Flow. YTD (Year To Date) option is only available for Cash Flow. (required)
        :return: FinancialStatements
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'statement', 'freq']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method financials" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `financials`")  # noqa: E501
        # verify the required parameter 'statement' is set
        if self.api_client.client_side_validation and ('statement' not in params or
                                                       params['statement'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `statement` when calling `financials`")  # noqa: E501
        # verify the required parameter 'freq' is set
        if self.api_client.client_side_validation and ('freq' not in params or
                                                       params['freq'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `freq` when calling `financials`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'statement' in params:
            query_params.append(('statement', params['statement']))  # noqa: E501
        if 'freq' in params:
            query_params.append(('freq', params['freq']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/financials', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FinancialStatements',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def financials_reported(self, **kwargs):  # noqa: E501
        """Financials As Reported  # noqa: E501

        Get financials as reported. This data is available for bulk download on <a href=\"https://www.kaggle.com/finnhub/reported-financials\" target=\"_blank\">Kaggle SEC Financials database</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.financials_reported(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol.
        :param str cik: CIK.
        :param str access_number: Access number of a specific report you want to retrieve financials from.
        :param str freq: Frequency. Can be either <code>annual</code> or <code>quarterly</code>. Default to <code>annual</code>.
        :return: FinancialsAsReported
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.financials_reported_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.financials_reported_with_http_info(**kwargs)  # noqa: E501
            return data

    def financials_reported_with_http_info(self, **kwargs):  # noqa: E501
        """Financials As Reported  # noqa: E501

        Get financials as reported. This data is available for bulk download on <a href=\"https://www.kaggle.com/finnhub/reported-financials\" target=\"_blank\">Kaggle SEC Financials database</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.financials_reported_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol.
        :param str cik: CIK.
        :param str access_number: Access number of a specific report you want to retrieve financials from.
        :param str freq: Frequency. Can be either <code>annual</code> or <code>quarterly</code>. Default to <code>annual</code>.
        :return: FinancialsAsReported
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'cik', 'access_number', 'freq']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method financials_reported" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'cik' in params:
            query_params.append(('cik', params['cik']))  # noqa: E501
        if 'access_number' in params:
            query_params.append(('accessNumber', params['access_number']))  # noqa: E501
        if 'freq' in params:
            query_params.append(('freq', params['freq']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/financials-reported', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FinancialsAsReported',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def forex_candles(self, symbol, resolution, _from, to, **kwargs):  # noqa: E501
        """Forex Candles  # noqa: E501

        Get candlestick data for forex symbols.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.forex_candles(symbol, resolution, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Use symbol returned in <code>/forex/symbol</code> endpoint for this field. (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :param int _from: UNIX timestamp. Interval initial value. (required)
        :param int to: UNIX timestamp. Interval end value. (required)
        :return: ForexCandles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.forex_candles_with_http_info(symbol, resolution, _from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.forex_candles_with_http_info(symbol, resolution, _from, to, **kwargs)  # noqa: E501
            return data

    def forex_candles_with_http_info(self, symbol, resolution, _from, to, **kwargs):  # noqa: E501
        """Forex Candles  # noqa: E501

        Get candlestick data for forex symbols.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.forex_candles_with_http_info(symbol, resolution, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Use symbol returned in <code>/forex/symbol</code> endpoint for this field. (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :param int _from: UNIX timestamp. Interval initial value. (required)
        :param int to: UNIX timestamp. Interval end value. (required)
        :return: ForexCandles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'resolution', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forex_candles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `forex_candles`")  # noqa: E501
        # verify the required parameter 'resolution' is set
        if self.api_client.client_side_validation and ('resolution' not in params or
                                                       params['resolution'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `resolution` when calling `forex_candles`")  # noqa: E501
        # verify the required parameter '_from' is set
        if self.api_client.client_side_validation and ('_from' not in params or
                                                       params['_from'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_from` when calling `forex_candles`")  # noqa: E501
        # verify the required parameter 'to' is set
        if self.api_client.client_side_validation and ('to' not in params or
                                                       params['to'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `to` when calling `forex_candles`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'resolution' in params:
            query_params.append(('resolution', params['resolution']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/forex/candle', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ForexCandles',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def forex_exchanges(self, **kwargs):  # noqa: E501
        """Forex Exchanges  # noqa: E501

        List supported forex exchanges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.forex_exchanges(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.forex_exchanges_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.forex_exchanges_with_http_info(**kwargs)  # noqa: E501
            return data

    def forex_exchanges_with_http_info(self, **kwargs):  # noqa: E501
        """Forex Exchanges  # noqa: E501

        List supported forex exchanges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.forex_exchanges_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forex_exchanges" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/forex/exchange', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def forex_rates(self, **kwargs):  # noqa: E501
        """Forex rates  # noqa: E501

        Get rates for all forex pairs. Ideal for currency conversion  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.forex_rates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str base: Base currency. Default to EUR.
        :return: Forexrates
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.forex_rates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.forex_rates_with_http_info(**kwargs)  # noqa: E501
            return data

    def forex_rates_with_http_info(self, **kwargs):  # noqa: E501
        """Forex rates  # noqa: E501

        Get rates for all forex pairs. Ideal for currency conversion  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.forex_rates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str base: Base currency. Default to EUR.
        :return: Forexrates
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forex_rates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'base' in params:
            query_params.append(('base', params['base']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/forex/rates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Forexrates',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def forex_symbols(self, exchange, **kwargs):  # noqa: E501
        """Forex Symbol  # noqa: E501

        List supported forex symbols.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.forex_symbols(exchange, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str exchange: Exchange you want to get the list of symbols from. (required)
        :return: list[ForexSymbol]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.forex_symbols_with_http_info(exchange, **kwargs)  # noqa: E501
        else:
            (data) = self.forex_symbols_with_http_info(exchange, **kwargs)  # noqa: E501
            return data

    def forex_symbols_with_http_info(self, exchange, **kwargs):  # noqa: E501
        """Forex Symbol  # noqa: E501

        List supported forex symbols.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.forex_symbols_with_http_info(exchange, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str exchange: Exchange you want to get the list of symbols from. (required)
        :return: list[ForexSymbol]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exchange']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forex_symbols" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'exchange' is set
        if self.api_client.client_side_validation and ('exchange' not in params or
                                                       params['exchange'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `exchange` when calling `forex_symbols`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/forex/symbol', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ForexSymbol]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fund_ownership(self, symbol, **kwargs):  # noqa: E501
        """Fund Ownership  # noqa: E501

        Get a full list fund and institutional investors of a company in descending order of the number of shares held. Data is sourced from <code>13F form</code>, <code>Schedule 13D</code> and <code>13G</code> for US market, <code>UK Share Register</code> for UK market, <code>SEDI</code> for Canadian market and equivalent filings for other international markets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fund_ownership(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param int limit: Limit number of results. Leave empty to get the full list.
        :return: FundOwnership
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fund_ownership_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.fund_ownership_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def fund_ownership_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Fund Ownership  # noqa: E501

        Get a full list fund and institutional investors of a company in descending order of the number of shares held. Data is sourced from <code>13F form</code>, <code>Schedule 13D</code> and <code>13G</code> for US market, <code>UK Share Register</code> for UK market, <code>SEDI</code> for Canadian market and equivalent filings for other international markets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fund_ownership_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param int limit: Limit number of results. Leave empty to get the full list.
        :return: FundOwnership
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fund_ownership" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `fund_ownership`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/fund-ownership', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FundOwnership',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def indices_constituents(self, symbol, **kwargs):  # noqa: E501
        """Indices Constituents  # noqa: E501

        Get a list of index's constituents. A list of supported indices for this endpoint can be found <a href=\"https://docs.google.com/spreadsheets/d/1Syr2eLielHWsorxkDEZXyc55d6bNx1M3ZeI4vdn7Qzo/edit?usp=sharing\" target=\"_blank\">here</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indices_constituents(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: symbol (required)
        :return: IndicesConstituents
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.indices_constituents_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.indices_constituents_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def indices_constituents_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Indices Constituents  # noqa: E501

        Get a list of index's constituents. A list of supported indices for this endpoint can be found <a href=\"https://docs.google.com/spreadsheets/d/1Syr2eLielHWsorxkDEZXyc55d6bNx1M3ZeI4vdn7Qzo/edit?usp=sharing\" target=\"_blank\">here</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indices_constituents_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: symbol (required)
        :return: IndicesConstituents
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method indices_constituents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `indices_constituents`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/index/constituents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IndicesConstituents',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def indices_historical_constituents(self, symbol, **kwargs):  # noqa: E501
        """Indices Historical Constituents  # noqa: E501

        Get full history of index's constituents including symbols and dates of joining and leaving the Index. Currently support <code>^GSPC (S&P 500)</code>, <code>^NDX (Nasdaq 100)</code>, <code>^DJI (Dow Jones)</code>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indices_historical_constituents(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: symbol (required)
        :return: IndicesHistoricalConstituents
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.indices_historical_constituents_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.indices_historical_constituents_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def indices_historical_constituents_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Indices Historical Constituents  # noqa: E501

        Get full history of index's constituents including symbols and dates of joining and leaving the Index. Currently support <code>^GSPC (S&P 500)</code>, <code>^NDX (Nasdaq 100)</code>, <code>^DJI (Dow Jones)</code>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indices_historical_constituents_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: symbol (required)
        :return: IndicesHistoricalConstituents
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method indices_historical_constituents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `indices_historical_constituents`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/index/historical-constituents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IndicesHistoricalConstituents',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insider_transactions(self, symbol, **kwargs):  # noqa: E501
        """Insider Transactions  # noqa: E501

        Company insider transactions data sourced from <code>Form 3,4,5</code>. This endpoint only covers US companies at the moment. Limit to 100 transactions per API call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insider_transactions(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param date _from: From date: 2020-03-15.
        :param date to: To date: 2020-03-16.
        :return: InsiderTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insider_transactions_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.insider_transactions_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def insider_transactions_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Insider Transactions  # noqa: E501

        Company insider transactions data sourced from <code>Form 3,4,5</code>. This endpoint only covers US companies at the moment. Limit to 100 transactions per API call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insider_transactions_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param date _from: From date: 2020-03-15.
        :param date to: To date: 2020-03-16.
        :return: InsiderTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insider_transactions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `insider_transactions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/insider-transactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InsiderTransactions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def international_filings(self, **kwargs):  # noqa: E501
        """International Filings  # noqa: E501

        List filings for international companies which covers 95%+ of global market cap. Limit to 250 documents at a time. These are the documents we use to source our fundamental data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.international_filings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. Leave empty to list latest filings.
        :param str country: Filter by country using country's 2-letter code.
        :return: list[InternationalFiling]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.international_filings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.international_filings_with_http_info(**kwargs)  # noqa: E501
            return data

    def international_filings_with_http_info(self, **kwargs):  # noqa: E501
        """International Filings  # noqa: E501

        List filings for international companies which covers 95%+ of global market cap. Limit to 250 documents at a time. These are the documents we use to source our fundamental data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.international_filings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. Leave empty to list latest filings.
        :param str country: Filter by country using country's 2-letter code.
        :return: list[InternationalFiling]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method international_filings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/international-filings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InternationalFiling]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def investment_themes(self, theme, **kwargs):  # noqa: E501
        """Investment Themes (Thematic Investing)  # noqa: E501

        <p>Thematic investing involves creating a portfolio (or portion of a portfolio) by gathering together a collection of companies involved in certain areas that you predict will generate above-market returns over the long term. Themes can be based on a concept such as ageing populations or a sub-sector such as robotics, and drones. Thematic investing focuses on predicted long-term trends rather than specific companies or sectors, enabling investors to access structural, one-off shifts that can change an entire industry.</p><p>This endpoint will help you get portfolios of different investment themes that are changing our life and are the way of the future.</p><p>A full list of themes supported can be found <a target=\"_blank\" href=\"https://docs.google.com/spreadsheets/d/1ULj9xDh4iPoQj279M084adZ2_S852ttRthKKJ7madYc/edit?usp=sharing\">here</a>. The theme coverage and portfolios are updated bi-weekly by our analysts. Our approach excludes penny, super-small cap and illiquid stocks.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.investment_themes(theme, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str theme: Investment theme. A full list of themes supported can be found <a target=\"_blank\" href=\"https://docs.google.com/spreadsheets/d/1ULj9xDh4iPoQj279M084adZ2_S852ttRthKKJ7madYc/edit?usp=sharing\">here</a>. (required)
        :return: InvestmentThemes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.investment_themes_with_http_info(theme, **kwargs)  # noqa: E501
        else:
            (data) = self.investment_themes_with_http_info(theme, **kwargs)  # noqa: E501
            return data

    def investment_themes_with_http_info(self, theme, **kwargs):  # noqa: E501
        """Investment Themes (Thematic Investing)  # noqa: E501

        <p>Thematic investing involves creating a portfolio (or portion of a portfolio) by gathering together a collection of companies involved in certain areas that you predict will generate above-market returns over the long term. Themes can be based on a concept such as ageing populations or a sub-sector such as robotics, and drones. Thematic investing focuses on predicted long-term trends rather than specific companies or sectors, enabling investors to access structural, one-off shifts that can change an entire industry.</p><p>This endpoint will help you get portfolios of different investment themes that are changing our life and are the way of the future.</p><p>A full list of themes supported can be found <a target=\"_blank\" href=\"https://docs.google.com/spreadsheets/d/1ULj9xDh4iPoQj279M084adZ2_S852ttRthKKJ7madYc/edit?usp=sharing\">here</a>. The theme coverage and portfolios are updated bi-weekly by our analysts. Our approach excludes penny, super-small cap and illiquid stocks.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.investment_themes_with_http_info(theme, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str theme: Investment theme. A full list of themes supported can be found <a target=\"_blank\" href=\"https://docs.google.com/spreadsheets/d/1ULj9xDh4iPoQj279M084adZ2_S852ttRthKKJ7madYc/edit?usp=sharing\">here</a>. (required)
        :return: InvestmentThemes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['theme']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method investment_themes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'theme' is set
        if self.api_client.client_side_validation and ('theme' not in params or
                                                       params['theme'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `theme` when calling `investment_themes`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'theme' in params:
            query_params.append(('theme', params['theme']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/investment-theme', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InvestmentThemes',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ipo_calendar(self, _from, to, **kwargs):  # noqa: E501
        """IPO Calendar  # noqa: E501

        Get recent and upcoming IPO.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ipo_calendar(_from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date _from: From date: 2020-03-15. (required)
        :param date to: To date: 2020-03-16. (required)
        :return: IPOCalendar
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ipo_calendar_with_http_info(_from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.ipo_calendar_with_http_info(_from, to, **kwargs)  # noqa: E501
            return data

    def ipo_calendar_with_http_info(self, _from, to, **kwargs):  # noqa: E501
        """IPO Calendar  # noqa: E501

        Get recent and upcoming IPO.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ipo_calendar_with_http_info(_from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date _from: From date: 2020-03-15. (required)
        :param date to: To date: 2020-03-16. (required)
        :return: IPOCalendar
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ipo_calendar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter '_from' is set
        if self.api_client.client_side_validation and ('_from' not in params or
                                                       params['_from'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_from` when calling `ipo_calendar`")  # noqa: E501
        # verify the required parameter 'to' is set
        if self.api_client.client_side_validation and ('to' not in params or
                                                       params['to'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `to` when calling `ipo_calendar`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/calendar/ipo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPOCalendar',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def market_news(self, category, **kwargs):  # noqa: E501
        """Market News  # noqa: E501

        Get latest market news.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.market_news(category, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str category: This parameter can be 1 of the following values <code>general, forex, crypto, merger</code>. (required)
        :param int min_id: Use this field to get only news after this ID. Default to 0
        :return: list[MarketNews]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.market_news_with_http_info(category, **kwargs)  # noqa: E501
        else:
            (data) = self.market_news_with_http_info(category, **kwargs)  # noqa: E501
            return data

    def market_news_with_http_info(self, category, **kwargs):  # noqa: E501
        """Market News  # noqa: E501

        Get latest market news.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.market_news_with_http_info(category, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str category: This parameter can be 1 of the following values <code>general, forex, crypto, merger</code>. (required)
        :param int min_id: Use this field to get only news after this ID. Default to 0
        :return: list[MarketNews]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category', 'min_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method market_news" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category' is set
        if self.api_client.client_side_validation and ('category' not in params or
                                                       params['category'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `category` when calling `market_news`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'min_id' in params:
            query_params.append(('minId', params['min_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/news', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MarketNews]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mutual_fund_country_exposure(self, symbol, **kwargs):  # noqa: E501
        """Mutual Funds Country Exposure  # noqa: E501

        Get Mutual Funds country exposure data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mutual_fund_country_exposure(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: MutualFundCountryExposure
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mutual_fund_country_exposure_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.mutual_fund_country_exposure_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def mutual_fund_country_exposure_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Mutual Funds Country Exposure  # noqa: E501

        Get Mutual Funds country exposure data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mutual_fund_country_exposure_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: MutualFundCountryExposure
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mutual_fund_country_exposure" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `mutual_fund_country_exposure`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/mutual-fund/country', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MutualFundCountryExposure',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mutual_fund_holdings(self, **kwargs):  # noqa: E501
        """Mutual Funds Holdings  # noqa: E501

        Get full Mutual Funds holdings/constituents.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mutual_fund_holdings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Fund's symbol.
        :param str isin: Fund's isin.
        :param int skip: Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip=0 or not set.
        :return: MutualFundHoldings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mutual_fund_holdings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.mutual_fund_holdings_with_http_info(**kwargs)  # noqa: E501
            return data

    def mutual_fund_holdings_with_http_info(self, **kwargs):  # noqa: E501
        """Mutual Funds Holdings  # noqa: E501

        Get full Mutual Funds holdings/constituents.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mutual_fund_holdings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Fund's symbol.
        :param str isin: Fund's isin.
        :param int skip: Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip=0 or not set.
        :return: MutualFundHoldings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'isin', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mutual_fund_holdings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'isin' in params:
            query_params.append(('isin', params['isin']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/mutual-fund/holdings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MutualFundHoldings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mutual_fund_profile(self, **kwargs):  # noqa: E501
        """Mutual Funds Profile  # noqa: E501

        Get mutual funds profile information. This endpoint covers US mutual funds only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mutual_fund_profile(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Fund's symbol.
        :param str isin: Fund's isin.
        :return: MutualFundProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mutual_fund_profile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.mutual_fund_profile_with_http_info(**kwargs)  # noqa: E501
            return data

    def mutual_fund_profile_with_http_info(self, **kwargs):  # noqa: E501
        """Mutual Funds Profile  # noqa: E501

        Get mutual funds profile information. This endpoint covers US mutual funds only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mutual_fund_profile_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Fund's symbol.
        :param str isin: Fund's isin.
        :return: MutualFundProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'isin']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mutual_fund_profile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'isin' in params:
            query_params.append(('isin', params['isin']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/mutual-fund/profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MutualFundProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mutual_fund_sector_exposure(self, symbol, **kwargs):  # noqa: E501
        """Mutual Funds Sector Exposure  # noqa: E501

        Get Mutual Funds sector exposure data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mutual_fund_sector_exposure(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Mutual Fund symbol. (required)
        :return: MutualFundSectorExposure
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mutual_fund_sector_exposure_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.mutual_fund_sector_exposure_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def mutual_fund_sector_exposure_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Mutual Funds Sector Exposure  # noqa: E501

        Get Mutual Funds sector exposure data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mutual_fund_sector_exposure_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Mutual Fund symbol. (required)
        :return: MutualFundSectorExposure
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mutual_fund_sector_exposure" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `mutual_fund_sector_exposure`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/mutual-fund/sector', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MutualFundSectorExposure',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def news_sentiment(self, symbol, **kwargs):  # noqa: E501
        """News Sentiment  # noqa: E501

        Get company's news sentiment and statistics. This endpoint is only available for US companies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.news_sentiment(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol. (required)
        :return: NewsSentiment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.news_sentiment_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.news_sentiment_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def news_sentiment_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """News Sentiment  # noqa: E501

        Get company's news sentiment and statistics. This endpoint is only available for US companies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.news_sentiment_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol. (required)
        :return: NewsSentiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method news_sentiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `news_sentiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/news-sentiment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NewsSentiment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ownership(self, symbol, **kwargs):  # noqa: E501
        """Ownership  # noqa: E501

        Get a full list of shareholders of a company in descending order of the number of shares held. Data is sourced from <code>13F form</code>, <code>Schedule 13D</code> and <code>13G</code> for US market, <code>UK Share Register</code> for UK market, <code>SEDI</code> for Canadian market and equivalent filings for other international markets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ownership(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param int limit: Limit number of results. Leave empty to get the full list.
        :return: Ownership
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ownership_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.ownership_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def ownership_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Ownership  # noqa: E501

        Get a full list of shareholders of a company in descending order of the number of shares held. Data is sourced from <code>13F form</code>, <code>Schedule 13D</code> and <code>13G</code> for US market, <code>UK Share Register</code> for UK market, <code>SEDI</code> for Canadian market and equivalent filings for other international markets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ownership_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :param int limit: Limit number of results. Leave empty to get the full list.
        :return: Ownership
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ownership" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `ownership`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/ownership', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ownership',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pattern_recognition(self, symbol, resolution, **kwargs):  # noqa: E501
        """Pattern Recognition  # noqa: E501

        Run pattern recognition algorithm on a symbol. Support double top/bottom, triple top/bottom, head and shoulders, triangle, wedge, channel, flag, and candlestick patterns.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pattern_recognition(symbol, resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :return: PatternRecognition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pattern_recognition_with_http_info(symbol, resolution, **kwargs)  # noqa: E501
        else:
            (data) = self.pattern_recognition_with_http_info(symbol, resolution, **kwargs)  # noqa: E501
            return data

    def pattern_recognition_with_http_info(self, symbol, resolution, **kwargs):  # noqa: E501
        """Pattern Recognition  # noqa: E501

        Run pattern recognition algorithm on a symbol. Support double top/bottom, triple top/bottom, head and shoulders, triangle, wedge, channel, flag, and candlestick patterns.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pattern_recognition_with_http_info(symbol, resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :return: PatternRecognition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'resolution']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pattern_recognition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `pattern_recognition`")  # noqa: E501
        # verify the required parameter 'resolution' is set
        if self.api_client.client_side_validation and ('resolution' not in params or
                                                       params['resolution'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `resolution` when calling `pattern_recognition`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'resolution' in params:
            query_params.append(('resolution', params['resolution']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/scan/pattern', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PatternRecognition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def press_releases(self, symbol, **kwargs):  # noqa: E501
        """Major Press Releases  # noqa: E501

        Get latest major press releases of a company. This data can be used to highlight the most significant events comprised of mostly press releases sourced from the exchanges, BusinessWire, AccessWire, GlobeNewswire, Newsfile, and PRNewswire.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.press_releases(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol. (required)
        :param date _from: From time: 2020-01-01.
        :param date to: To time: 2020-01-05.
        :return: PressRelease
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.press_releases_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.press_releases_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def press_releases_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Major Press Releases  # noqa: E501

        Get latest major press releases of a company. This data can be used to highlight the most significant events comprised of mostly press releases sourced from the exchanges, BusinessWire, AccessWire, GlobeNewswire, Newsfile, and PRNewswire.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.press_releases_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol. (required)
        :param date _from: From time: 2020-01-01.
        :param date to: To time: 2020-01-05.
        :return: PressRelease
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method press_releases" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `press_releases`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/press-releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PressRelease',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def price_target(self, symbol, **kwargs):  # noqa: E501
        """Price Target  # noqa: E501

        Get latest price target consensus.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.price_target(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :return: PriceTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.price_target_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.price_target_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def price_target_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Price Target  # noqa: E501

        Get latest price target consensus.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.price_target_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :return: PriceTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method price_target" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `price_target`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/price-target', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PriceTarget',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quote(self, symbol, **kwargs):  # noqa: E501
        """Quote  # noqa: E501

        <p>Get real-time quote data for US stocks. Constant polling is not recommended. Use websocket if you need real-time updates.</p><p>Real-time stock prices for international markets are supported for Enterprise clients via our partner's feed. <a href=\"mailto:support@finnhub.io\">Contact Us</a> to learn more.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quote(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol (required)
        :return: Quote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quote_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.quote_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def quote_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Quote  # noqa: E501

        <p>Get real-time quote data for US stocks. Constant polling is not recommended. Use websocket if you need real-time updates.</p><p>Real-time stock prices for international markets are supported for Enterprise clients via our partner's feed. <a href=\"mailto:support@finnhub.io\">Contact Us</a> to learn more.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quote_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol (required)
        :return: Quote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quote" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `quote`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/quote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Quote',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recommendation_trends(self, symbol, **kwargs):  # noqa: E501
        """Recommendation Trends  # noqa: E501

        Get latest analyst recommendation trends for a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recommendation_trends(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :return: list[RecommendationTrend]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recommendation_trends_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.recommendation_trends_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def recommendation_trends_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Recommendation Trends  # noqa: E501

        Get latest analyst recommendation trends for a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recommendation_trends_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. (required)
        :return: list[RecommendationTrend]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recommendation_trends" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `recommendation_trends`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/recommendation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RecommendationTrend]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revenue_breakdown(self, **kwargs):  # noqa: E501
        """Revenue Breakdown  # noqa: E501

        Get revenue breakdown by product. This dataset is only available for US companies which disclose their revenue breakdown in the annual or quarterly reports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revenue_breakdown(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol.
        :param str cik: CIK.
        :return: RevenueBreakdown
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revenue_breakdown_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.revenue_breakdown_with_http_info(**kwargs)  # noqa: E501
            return data

    def revenue_breakdown_with_http_info(self, **kwargs):  # noqa: E501
        """Revenue Breakdown  # noqa: E501

        Get revenue breakdown by product. This dataset is only available for US companies which disclose their revenue breakdown in the annual or quarterly reports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revenue_breakdown_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol.
        :param str cik: CIK.
        :return: RevenueBreakdown
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'cik']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revenue_breakdown" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'cik' in params:
            query_params.append(('cik', params['cik']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/revenue-breakdown', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevenueBreakdown',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def similarity_index(self, **kwargs):  # noqa: E501
        """Similarity Index  # noqa: E501

        <p>Calculate the textual difference between a company's 10-K / 10-Q reports and the same type of report in the previous year using Cosine Similarity. For example, this endpoint compares 2019's 10-K with 2018's 10-K. Companies breaking from its routines in disclosure of financial condition and risk analysis section can signal a significant change in the company's stock price in the upcoming 4 quarters.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.similarity_index(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. Required if cik is empty
        :param str cik: CIK. Required if symbol is empty
        :param str freq: <code>annual</code> or <code>quarterly</code>. Default to <code>annual</code>
        :return: SimilarityIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.similarity_index_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.similarity_index_with_http_info(**kwargs)  # noqa: E501
            return data

    def similarity_index_with_http_info(self, **kwargs):  # noqa: E501
        """Similarity Index  # noqa: E501

        <p>Calculate the textual difference between a company's 10-K / 10-Q reports and the same type of report in the previous year using Cosine Similarity. For example, this endpoint compares 2019's 10-K with 2018's 10-K. Companies breaking from its routines in disclosure of financial condition and risk analysis section can signal a significant change in the company's stock price in the upcoming 4 quarters.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.similarity_index_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. Required if cik is empty
        :param str cik: CIK. Required if symbol is empty
        :param str freq: <code>annual</code> or <code>quarterly</code>. Default to <code>annual</code>
        :return: SimilarityIndex
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'cik', 'freq']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method similarity_index" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'cik' in params:
            query_params.append(('cik', params['cik']))  # noqa: E501
        if 'freq' in params:
            query_params.append(('freq', params['freq']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/similarity-index', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimilarityIndex',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def social_sentiment(self, symbol, **kwargs):  # noqa: E501
        """Social Sentiment  # noqa: E501

        <p>Get social sentiment for stocks on Reddit and Twitter. This endpoint is currently in Beta.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.social_sentiment(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol. (required)
        :param date _from: From date <code>YYYY-MM-DD</code>.
        :param date to: To date <code>YYYY-MM-DD</code>.
        :return: SocialSentiment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.social_sentiment_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.social_sentiment_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def social_sentiment_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Social Sentiment  # noqa: E501

        <p>Get social sentiment for stocks on Reddit and Twitter. This endpoint is currently in Beta.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.social_sentiment_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol. (required)
        :param date _from: From date <code>YYYY-MM-DD</code>.
        :param date to: To date <code>YYYY-MM-DD</code>.
        :return: SocialSentiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method social_sentiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `social_sentiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/social-sentiment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SocialSentiment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stock_basic_dividends(self, symbol, **kwargs):  # noqa: E501
        """Dividends 2 (Basic)  # noqa: E501

        Get global dividends data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_basic_dividends(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: Dividends2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stock_basic_dividends_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.stock_basic_dividends_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def stock_basic_dividends_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Dividends 2 (Basic)  # noqa: E501

        Get global dividends data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_basic_dividends_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: Dividends2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stock_basic_dividends" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `stock_basic_dividends`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/dividend2', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Dividends2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stock_bidask(self, symbol, **kwargs):  # noqa: E501
        """Last Bid-Ask  # noqa: E501

        Get last bid/ask data for US stocks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_bidask(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: LastBidAsk
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stock_bidask_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.stock_bidask_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def stock_bidask_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Last Bid-Ask  # noqa: E501

        Get last bid/ask data for US stocks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_bidask_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: LastBidAsk
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stock_bidask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `stock_bidask`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/bidask', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LastBidAsk',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stock_candles(self, symbol, resolution, _from, to, **kwargs):  # noqa: E501
        """Stock Candles  # noqa: E501

        <p>Get candlestick data (OHLCV) for stocks.</p><p>Daily data will be adjusted for Splits. Intraday data will remain unadjusted.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_candles(symbol, resolution, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :param int _from: UNIX timestamp. Interval initial value. (required)
        :param int to: UNIX timestamp. Interval end value. (required)
        :return: StockCandles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stock_candles_with_http_info(symbol, resolution, _from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.stock_candles_with_http_info(symbol, resolution, _from, to, **kwargs)  # noqa: E501
            return data

    def stock_candles_with_http_info(self, symbol, resolution, _from, to, **kwargs):  # noqa: E501
        """Stock Candles  # noqa: E501

        <p>Get candlestick data (OHLCV) for stocks.</p><p>Daily data will be adjusted for Splits. Intraday data will remain unadjusted.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_candles_with_http_info(symbol, resolution, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :param int _from: UNIX timestamp. Interval initial value. (required)
        :param int to: UNIX timestamp. Interval end value. (required)
        :return: StockCandles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'resolution', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stock_candles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `stock_candles`")  # noqa: E501
        # verify the required parameter 'resolution' is set
        if self.api_client.client_side_validation and ('resolution' not in params or
                                                       params['resolution'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `resolution` when calling `stock_candles`")  # noqa: E501
        # verify the required parameter '_from' is set
        if self.api_client.client_side_validation and ('_from' not in params or
                                                       params['_from'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_from` when calling `stock_candles`")  # noqa: E501
        # verify the required parameter 'to' is set
        if self.api_client.client_side_validation and ('to' not in params or
                                                       params['to'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `to` when calling `stock_candles`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'resolution' in params:
            query_params.append(('resolution', params['resolution']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/candle', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StockCandles',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stock_dividends(self, symbol, _from, to, **kwargs):  # noqa: E501
        """Dividends  # noqa: E501

        Get dividends data for common stocks going back 30 years.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_dividends(symbol, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param date _from: YYYY-MM-DD. (required)
        :param date to: YYYY-MM-DD. (required)
        :return: list[Dividends]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stock_dividends_with_http_info(symbol, _from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.stock_dividends_with_http_info(symbol, _from, to, **kwargs)  # noqa: E501
            return data

    def stock_dividends_with_http_info(self, symbol, _from, to, **kwargs):  # noqa: E501
        """Dividends  # noqa: E501

        Get dividends data for common stocks going back 30 years.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_dividends_with_http_info(symbol, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param date _from: YYYY-MM-DD. (required)
        :param date to: YYYY-MM-DD. (required)
        :return: list[Dividends]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stock_dividends" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `stock_dividends`")  # noqa: E501
        # verify the required parameter '_from' is set
        if self.api_client.client_side_validation and ('_from' not in params or
                                                       params['_from'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_from` when calling `stock_dividends`")  # noqa: E501
        # verify the required parameter 'to' is set
        if self.api_client.client_side_validation and ('to' not in params or
                                                       params['to'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `to` when calling `stock_dividends`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/dividend', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Dividends]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stock_nbbo(self, symbol, _date, limit, skip, **kwargs):  # noqa: E501
        """Historical NBBO  # noqa: E501

        <p>Get historical best bid and offer for US stocks, LSE, TSX, Euronext and Deutsche Borse.</p><p>For US market, this endpoint only serves historical NBBO from the beginning of 2020. To download more historical data, please visit our bulk download page in the Dashboard <a target=\"_blank\" href=\"/dashboard/download\",>here</a>.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_nbbo(symbol, _date, limit, skip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param date _date: Date: 2020-04-02. (required)
        :param int limit: Limit number of ticks returned. Maximum value: <code>25000</code> (required)
        :param int skip: Number of ticks to skip. Use this parameter to loop through the entire data. (required)
        :return: HistoricalNBBO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stock_nbbo_with_http_info(symbol, _date, limit, skip, **kwargs)  # noqa: E501
        else:
            (data) = self.stock_nbbo_with_http_info(symbol, _date, limit, skip, **kwargs)  # noqa: E501
            return data

    def stock_nbbo_with_http_info(self, symbol, _date, limit, skip, **kwargs):  # noqa: E501
        """Historical NBBO  # noqa: E501

        <p>Get historical best bid and offer for US stocks, LSE, TSX, Euronext and Deutsche Borse.</p><p>For US market, this endpoint only serves historical NBBO from the beginning of 2020. To download more historical data, please visit our bulk download page in the Dashboard <a target=\"_blank\" href=\"/dashboard/download\",>here</a>.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_nbbo_with_http_info(symbol, _date, limit, skip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param date _date: Date: 2020-04-02. (required)
        :param int limit: Limit number of ticks returned. Maximum value: <code>25000</code> (required)
        :param int skip: Number of ticks to skip. Use this parameter to loop through the entire data. (required)
        :return: HistoricalNBBO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', '_date', 'limit', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stock_nbbo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `stock_nbbo`")  # noqa: E501
        # verify the required parameter '_date' is set
        if self.api_client.client_side_validation and ('_date' not in params or
                                                       params['_date'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_date` when calling `stock_nbbo`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in params or
                                                       params['limit'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `limit` when calling `stock_nbbo`")  # noqa: E501
        # verify the required parameter 'skip' is set
        if self.api_client.client_side_validation and ('skip' not in params or
                                                       params['skip'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `skip` when calling `stock_nbbo`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/bbo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoricalNBBO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stock_splits(self, symbol, _from, to, **kwargs):  # noqa: E501
        """Splits  # noqa: E501

        Get splits data for stocks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_splits(symbol, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param date _from: YYYY-MM-DD. (required)
        :param date to: YYYY-MM-DD. (required)
        :return: list[Split]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stock_splits_with_http_info(symbol, _from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.stock_splits_with_http_info(symbol, _from, to, **kwargs)  # noqa: E501
            return data

    def stock_splits_with_http_info(self, symbol, _from, to, **kwargs):  # noqa: E501
        """Splits  # noqa: E501

        Get splits data for stocks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_splits_with_http_info(symbol, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param date _from: YYYY-MM-DD. (required)
        :param date to: YYYY-MM-DD. (required)
        :return: list[Split]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stock_splits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `stock_splits`")  # noqa: E501
        # verify the required parameter '_from' is set
        if self.api_client.client_side_validation and ('_from' not in params or
                                                       params['_from'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_from` when calling `stock_splits`")  # noqa: E501
        # verify the required parameter 'to' is set
        if self.api_client.client_side_validation and ('to' not in params or
                                                       params['to'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `to` when calling `stock_splits`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/split', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Split]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stock_symbols(self, exchange, **kwargs):  # noqa: E501
        """Stock Symbol  # noqa: E501

        List supported stocks. We use the following symbology to identify stocks on Finnhub <code>Exchange_Ticker.Exchange_Code</code>. A list of supported exchange codes can be found <a href=\"https://docs.google.com/spreadsheets/d/1I3pBxjfXB056-g_JYf_6o3Rns3BV2kMGG1nCatb91ls/edit?usp=sharing\" target=\"_blank\">here</a>. A list of supported CFD Indices can be found <a href=\"https://docs.google.com/spreadsheets/d/1BAbIXBgl405fj0oHeEyRFEu8mW4QD1PhvtaBATLoR14/edit?usp=sharing\" target=\"_blank\">here</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_symbols(exchange, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str exchange: Exchange you want to get the list of symbols from. List of exchange codes can be found <a href=\"https://docs.google.com/spreadsheets/d/1I3pBxjfXB056-g_JYf_6o3Rns3BV2kMGG1nCatb91ls/edit?usp=sharing\" target=\"_blank\">here</a>. (required)
        :param str mic: Filter by MIC code.
        :param str security_type: Filter by security type used by OpenFigi standard.
        :param str currency: Filter by currency.
        :return: list[StockSymbol]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stock_symbols_with_http_info(exchange, **kwargs)  # noqa: E501
        else:
            (data) = self.stock_symbols_with_http_info(exchange, **kwargs)  # noqa: E501
            return data

    def stock_symbols_with_http_info(self, exchange, **kwargs):  # noqa: E501
        """Stock Symbol  # noqa: E501

        List supported stocks. We use the following symbology to identify stocks on Finnhub <code>Exchange_Ticker.Exchange_Code</code>. A list of supported exchange codes can be found <a href=\"https://docs.google.com/spreadsheets/d/1I3pBxjfXB056-g_JYf_6o3Rns3BV2kMGG1nCatb91ls/edit?usp=sharing\" target=\"_blank\">here</a>. A list of supported CFD Indices can be found <a href=\"https://docs.google.com/spreadsheets/d/1BAbIXBgl405fj0oHeEyRFEu8mW4QD1PhvtaBATLoR14/edit?usp=sharing\" target=\"_blank\">here</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_symbols_with_http_info(exchange, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str exchange: Exchange you want to get the list of symbols from. List of exchange codes can be found <a href=\"https://docs.google.com/spreadsheets/d/1I3pBxjfXB056-g_JYf_6o3Rns3BV2kMGG1nCatb91ls/edit?usp=sharing\" target=\"_blank\">here</a>. (required)
        :param str mic: Filter by MIC code.
        :param str security_type: Filter by security type used by OpenFigi standard.
        :param str currency: Filter by currency.
        :return: list[StockSymbol]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exchange', 'mic', 'security_type', 'currency']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stock_symbols" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'exchange' is set
        if self.api_client.client_side_validation and ('exchange' not in params or
                                                       params['exchange'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `exchange` when calling `stock_symbols`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exchange' in params:
            query_params.append(('exchange', params['exchange']))  # noqa: E501
        if 'mic' in params:
            query_params.append(('mic', params['mic']))  # noqa: E501
        if 'security_type' in params:
            query_params.append(('securityType', params['security_type']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/symbol', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StockSymbol]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stock_tick(self, symbol, _date, limit, skip, **kwargs):  # noqa: E501
        """Tick Data  # noqa: E501

        <p>Get historical tick data for global exchanges. You can send the request directly to our tick server at <a href=\"https://tick.finnhub.io/\">https://tick.finnhub.io/</a> with the same path and parameters or get redirected there if you call our main server.</p><p>For US market, you can visit our bulk download page in the Dashboard <a target=\"_blank\" href=\"/dashboard/download\",>here</a> to speed up the download process.</p><table class=\"table table-hover\">   <thead>     <tr>       <th>Exchange</th>       <th>Segment</th>       <th>Delay</th>     </tr>   </thead>   <tbody>     <tr>       <td class=\"text-blue\">US CTA/UTP</th>       <td>Full SIP</td>       <td>15 minute</td>     </tr>     <tr>       <td class=\"text-blue\">TSX</th>       <td><ul><li>TSX</li><li>TSX Venture</li><li>Index</li></ul></td>       <td>End-of-day</td>     </tr>     <tr>       <td class=\"text-blue\">LSE</th>       <td><ul><li>London Stock Exchange (L)</li><li>LSE International (L)</li><li>LSE European (L)</li></ul></td>       <td>15 minute</td>     </tr>     <tr>       <td class=\"text-blue\">Euronext</th>       <td><ul> <li>Euronext Paris (PA)</li> <li>Euronext Amsterdam (AS)</li> <li>Euronext Lisbon (LS)</li> <li>Euronext Brussels (BR)</li> <li>Euronext Oslo (OL)</li> <li>Euronext London (LN)</li> <li>Euronext Dublin (IR)</li> <li>Index</li> <li>Warrant</li></ul></td>       <td>End-of-day</td>     </tr>     <tr>       <td class=\"text-blue\">Deutsche Börse</th>       <td><ul> <li>Frankfurt (F)</li> <li>Xetra (DE)</li> <li>Duesseldorf (DU)</li> <li>Hamburg (HM)</li> <li>Berlin (BE)</li> <li>Hanover (HA)</li> <li>Stoxx (SX)</li> <li>TradeGate (TG)</li> <li>Zertifikate (SC)</li> <li>Index</li> <li>Warrant</li></ul></td>       <td>End-of-day</td>     </tr>     <tr>       <td class=\"text-blue\">Nasdaq Nordic & Baltic</th>       <td> <ul> <li>Copenhagen (CO)</li> <li>Stockholm (ST)</li> <li>Helsinki (HE)</li> <li>Iceland (IC)</li> <li>Riga (RG)</li> <li>Tallinn (TL)</li> <li>Vilnius(VS)</li> <li>Fixed Income</li> <li>Derivatives</li> <li>Commodities</li></ul></td>       <td>End-of-day</td>     </tr>   </tbody> </table>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_tick(symbol, _date, limit, skip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param date _date: Date: 2020-04-02. (required)
        :param int limit: Limit number of ticks returned. Maximum value: <code>25000</code> (required)
        :param int skip: Number of ticks to skip. Use this parameter to loop through the entire data. (required)
        :return: TickData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stock_tick_with_http_info(symbol, _date, limit, skip, **kwargs)  # noqa: E501
        else:
            (data) = self.stock_tick_with_http_info(symbol, _date, limit, skip, **kwargs)  # noqa: E501
            return data

    def stock_tick_with_http_info(self, symbol, _date, limit, skip, **kwargs):  # noqa: E501
        """Tick Data  # noqa: E501

        <p>Get historical tick data for global exchanges. You can send the request directly to our tick server at <a href=\"https://tick.finnhub.io/\">https://tick.finnhub.io/</a> with the same path and parameters or get redirected there if you call our main server.</p><p>For US market, you can visit our bulk download page in the Dashboard <a target=\"_blank\" href=\"/dashboard/download\",>here</a> to speed up the download process.</p><table class=\"table table-hover\">   <thead>     <tr>       <th>Exchange</th>       <th>Segment</th>       <th>Delay</th>     </tr>   </thead>   <tbody>     <tr>       <td class=\"text-blue\">US CTA/UTP</th>       <td>Full SIP</td>       <td>15 minute</td>     </tr>     <tr>       <td class=\"text-blue\">TSX</th>       <td><ul><li>TSX</li><li>TSX Venture</li><li>Index</li></ul></td>       <td>End-of-day</td>     </tr>     <tr>       <td class=\"text-blue\">LSE</th>       <td><ul><li>London Stock Exchange (L)</li><li>LSE International (L)</li><li>LSE European (L)</li></ul></td>       <td>15 minute</td>     </tr>     <tr>       <td class=\"text-blue\">Euronext</th>       <td><ul> <li>Euronext Paris (PA)</li> <li>Euronext Amsterdam (AS)</li> <li>Euronext Lisbon (LS)</li> <li>Euronext Brussels (BR)</li> <li>Euronext Oslo (OL)</li> <li>Euronext London (LN)</li> <li>Euronext Dublin (IR)</li> <li>Index</li> <li>Warrant</li></ul></td>       <td>End-of-day</td>     </tr>     <tr>       <td class=\"text-blue\">Deutsche Börse</th>       <td><ul> <li>Frankfurt (F)</li> <li>Xetra (DE)</li> <li>Duesseldorf (DU)</li> <li>Hamburg (HM)</li> <li>Berlin (BE)</li> <li>Hanover (HA)</li> <li>Stoxx (SX)</li> <li>TradeGate (TG)</li> <li>Zertifikate (SC)</li> <li>Index</li> <li>Warrant</li></ul></td>       <td>End-of-day</td>     </tr>     <tr>       <td class=\"text-blue\">Nasdaq Nordic & Baltic</th>       <td> <ul> <li>Copenhagen (CO)</li> <li>Stockholm (ST)</li> <li>Helsinki (HE)</li> <li>Iceland (IC)</li> <li>Riga (RG)</li> <li>Tallinn (TL)</li> <li>Vilnius(VS)</li> <li>Fixed Income</li> <li>Derivatives</li> <li>Commodities</li></ul></td>       <td>End-of-day</td>     </tr>   </tbody> </table>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stock_tick_with_http_info(symbol, _date, limit, skip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :param date _date: Date: 2020-04-02. (required)
        :param int limit: Limit number of ticks returned. Maximum value: <code>25000</code> (required)
        :param int skip: Number of ticks to skip. Use this parameter to loop through the entire data. (required)
        :return: TickData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', '_date', 'limit', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stock_tick" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `stock_tick`")  # noqa: E501
        # verify the required parameter '_date' is set
        if self.api_client.client_side_validation and ('_date' not in params or
                                                       params['_date'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_date` when calling `stock_tick`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in params or
                                                       params['limit'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `limit` when calling `stock_tick`")  # noqa: E501
        # verify the required parameter 'skip' is set
        if self.api_client.client_side_validation and ('skip' not in params or
                                                       params['skip'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `skip` when calling `stock_tick`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/tick', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TickData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def supply_chain_relationships(self, symbol, **kwargs):  # noqa: E501
        """Supply Chain Relationships  # noqa: E501

        <p>This endpoint provides an overall map of public companies' key customers and suppliers. The data offers a deeper look into a company's supply chain and how products are created. The data will help investors manage risk, limit exposure or generate alpha-generating ideas and trading insights.</p><p>We currently cover data for S&P500 and Nasdaq 100 companies.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.supply_chain_relationships(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: SupplyChainRelationships
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.supply_chain_relationships_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.supply_chain_relationships_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def supply_chain_relationships_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Supply Chain Relationships  # noqa: E501

        <p>This endpoint provides an overall map of public companies' key customers and suppliers. The data offers a deeper look into a company's supply chain and how products are created. The data will help investors manage risk, limit exposure or generate alpha-generating ideas and trading insights.</p><p>We currently cover data for S&P500 and Nasdaq 100 companies.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.supply_chain_relationships_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol. (required)
        :return: SupplyChainRelationships
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method supply_chain_relationships" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `supply_chain_relationships`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/supply-chain', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SupplyChainRelationships',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def support_resistance(self, symbol, resolution, **kwargs):  # noqa: E501
        """Support/Resistance  # noqa: E501

        Get support and resistance levels for a symbol.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.support_resistance(symbol, resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :return: SupportResistance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.support_resistance_with_http_info(symbol, resolution, **kwargs)  # noqa: E501
        else:
            (data) = self.support_resistance_with_http_info(symbol, resolution, **kwargs)  # noqa: E501
            return data

    def support_resistance_with_http_info(self, symbol, resolution, **kwargs):  # noqa: E501
        """Support/Resistance  # noqa: E501

        Get support and resistance levels for a symbol.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.support_resistance_with_http_info(symbol, resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :return: SupportResistance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'resolution']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method support_resistance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `support_resistance`")  # noqa: E501
        # verify the required parameter 'resolution' is set
        if self.api_client.client_side_validation and ('resolution' not in params or
                                                       params['resolution'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `resolution` when calling `support_resistance`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'resolution' in params:
            query_params.append(('resolution', params['resolution']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/scan/support-resistance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SupportResistance',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def symbol_search(self, q, **kwargs):  # noqa: E501
        """Symbol Lookup  # noqa: E501

        Search for best-matching symbols based on your query. You can input anything from symbol, security's name to ISIN and Cusip.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.symbol_search(q, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q: Query text can be symbol, name, isin, or cusip. (required)
        :return: SymbolLookup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.symbol_search_with_http_info(q, **kwargs)  # noqa: E501
        else:
            (data) = self.symbol_search_with_http_info(q, **kwargs)  # noqa: E501
            return data

    def symbol_search_with_http_info(self, q, **kwargs):  # noqa: E501
        """Symbol Lookup  # noqa: E501

        Search for best-matching symbols based on your query. You can input anything from symbol, security's name to ISIN and Cusip.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.symbol_search_with_http_info(q, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q: Query text can be symbol, name, isin, or cusip. (required)
        :return: SymbolLookup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method symbol_search" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'q' is set
        if self.api_client.client_side_validation and ('q' not in params or
                                                       params['q'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `q` when calling `symbol_search`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SymbolLookup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def technical_indicator(self, symbol, resolution, _from, to, indicator, **kwargs):  # noqa: E501
        """Technical Indicators  # noqa: E501

        Return technical indicator with price data. List of supported indicators can be found <a href=\"https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp=sharing\" target=\"_blank\">here</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.technical_indicator(symbol, resolution, _from, to, indicator, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: symbol (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :param int _from: UNIX timestamp. Interval initial value. (required)
        :param int to: UNIX timestamp. Interval end value. (required)
        :param str indicator: Indicator name. Full list can be found <a href=\"https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp=sharing\" target=\"_blank\">here</a>. (required)
        :param IndicatorFields indicator_fields: Check out <a href=\"https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp=sharing\" target=\"_blank\">this page</a> to see which indicators and params are supported.
        :return: TechnicalIndicator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.technical_indicator_with_http_info(symbol, resolution, _from, to, indicator, **kwargs)  # noqa: E501
        else:
            (data) = self.technical_indicator_with_http_info(symbol, resolution, _from, to, indicator, **kwargs)  # noqa: E501
            return data

    def technical_indicator_with_http_info(self, symbol, resolution, _from, to, indicator, **kwargs):  # noqa: E501
        """Technical Indicators  # noqa: E501

        Return technical indicator with price data. List of supported indicators can be found <a href=\"https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp=sharing\" target=\"_blank\">here</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.technical_indicator_with_http_info(symbol, resolution, _from, to, indicator, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: symbol (required)
        :param str resolution: Supported resolution includes <code>1, 5, 15, 30, 60, D, W, M </code>.Some timeframes might not be available depending on the exchange. (required)
        :param int _from: UNIX timestamp. Interval initial value. (required)
        :param int to: UNIX timestamp. Interval end value. (required)
        :param str indicator: Indicator name. Full list can be found <a href=\"https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp=sharing\" target=\"_blank\">here</a>. (required)
        :param IndicatorFields indicator_fields: Check out <a href=\"https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp=sharing\" target=\"_blank\">this page</a> to see which indicators and params are supported.
        :return: TechnicalIndicator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'resolution', '_from', 'to', 'indicator', 'indicator_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method technical_indicator" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `technical_indicator`")  # noqa: E501
        # verify the required parameter 'resolution' is set
        if self.api_client.client_side_validation and ('resolution' not in params or
                                                       params['resolution'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `resolution` when calling `technical_indicator`")  # noqa: E501
        # verify the required parameter '_from' is set
        if self.api_client.client_side_validation and ('_from' not in params or
                                                       params['_from'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `_from` when calling `technical_indicator`")  # noqa: E501
        # verify the required parameter 'to' is set
        if self.api_client.client_side_validation and ('to' not in params or
                                                       params['to'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `to` when calling `technical_indicator`")  # noqa: E501
        # verify the required parameter 'indicator' is set
        if self.api_client.client_side_validation and ('indicator' not in params or
                                                       params['indicator'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `indicator` when calling `technical_indicator`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'resolution' in params:
            query_params.append(('resolution', params['resolution']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'indicator' in params:
            query_params.append(('indicator', params['indicator']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'indicator_fields' in params:
            body_params = params['indicator_fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/indicator', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TechnicalIndicator',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transcripts(self, id, **kwargs):  # noqa: E501
        """Earnings Call Transcripts  # noqa: E501

        <p>Get earnings call transcripts, audio and participants' list. This endpoint is only available for US, UK, and Candian companies. <p>15+ years of data is available with 220,000+ audio which add up to 7TB in size.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcripts(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Transcript's id obtained with <a href=\"#transcripts-list\">Transcripts List endpoint</a>. (required)
        :return: EarningsCallTranscripts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.transcripts_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.transcripts_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def transcripts_with_http_info(self, id, **kwargs):  # noqa: E501
        """Earnings Call Transcripts  # noqa: E501

        <p>Get earnings call transcripts, audio and participants' list. This endpoint is only available for US, UK, and Candian companies. <p>15+ years of data is available with 220,000+ audio which add up to 7TB in size.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcripts_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Transcript's id obtained with <a href=\"#transcripts-list\">Transcripts List endpoint</a>. (required)
        :return: EarningsCallTranscripts
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcripts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `transcripts`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/transcripts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EarningsCallTranscripts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transcripts_list(self, symbol, **kwargs):  # noqa: E501
        """Earnings Call Transcripts List  # noqa: E501

        List earnings call transcripts' metadata. This endpoint is available for US, UK and Canadian companies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcripts_list(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol: AAPL. Leave empty to list the latest transcripts (required)
        :return: EarningsCallTranscriptsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.transcripts_list_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.transcripts_list_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def transcripts_list_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Earnings Call Transcripts List  # noqa: E501

        List earnings call transcripts' metadata. This endpoint is available for US, UK and Canadian companies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcripts_list_with_http_info(symbol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Company symbol: AAPL. Leave empty to list the latest transcripts (required)
        :return: EarningsCallTranscriptsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcripts_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if self.api_client.client_side_validation and ('symbol' not in params or
                                                       params['symbol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `symbol` when calling `transcripts_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/transcripts/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EarningsCallTranscriptsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upgrade_downgrade(self, **kwargs):  # noqa: E501
        """Stock Upgrade/Downgrade  # noqa: E501

        Get latest stock upgrade and downgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_downgrade(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. If left blank, the API will return latest stock upgrades/downgrades.
        :param date _from: From date: 2000-03-15.
        :param date to: To date: 2020-03-16.
        :return: list[UpgradeDowngrade]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upgrade_downgrade_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.upgrade_downgrade_with_http_info(**kwargs)  # noqa: E501
            return data

    def upgrade_downgrade_with_http_info(self, **kwargs):  # noqa: E501
        """Stock Upgrade/Downgrade  # noqa: E501

        Get latest stock upgrade and downgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_downgrade_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Symbol of the company: AAPL. If left blank, the API will return latest stock upgrades/downgrades.
        :param date _from: From date: 2000-03-15.
        :param date to: To date: 2020-03-16.
        :return: list[UpgradeDowngrade]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upgrade_downgrade" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/stock/upgrade-downgrade', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UpgradeDowngrade]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
